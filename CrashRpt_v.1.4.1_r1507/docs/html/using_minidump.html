<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CrashRpt: Using Crash Minidump</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>

<div style="padding:10px">
<table border="0" bgcolor="#FFFFFF" cellspacing="5" width="100%">
 <tr>
  <td width="24px" rowspan="2"><img src="../logo.png" alt="Logo" /></td>
  <td><font family="Arial" size="+2">crashrpt</font></td>
  <td rowspan="2" align="right"></td>
 </tr>
 <tr>
  <td colspan="2"><span style="font-size:0.9em"><i>A crash reporting system for Windows applications</i></a></td>
 </tr>
</table>
</div>


<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Contents</span></a></li>
      <li><a href="modules.html"><span>API&nbsp;Reference</span></a></li>
      <li><a href="files.html"><span>File&nbsp;Reference</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">CrashRpt Documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="using_error_reports.html">Using Error Reports</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="using_minidump">Using Crash Minidump </a></h1>You can open minidump files generated by CrashRpt in Visual Studio or in WinDbg.<p>
This page covers the following topics:<ul>
<li><a class="el" href="using_minidump.html#about_minidump">About Crash Minidump</a></li><li><a class="el" href="using_minidump.html#opening_minidump_in_vs">Opening Minidump in Visual Studio</a></li><li><a class="el" href="using_minidump.html#opening_minidump_in_windbg">Opening Minidump in WinDbg</a></li></ul>
<h2><a class="anchor" name="about_minidump">
About Crash Minidump</a></h2>
The minidump (DMP file) contains various information about the state of the application when the error occurred. The minidump is usually created with the help of the DbgHelp DLL's <b>MiniDumpWriteDump()</b> function.<p>
The crash minidump file may contain:<ul>
<li>general system information;</li><li>call stack and local variables for each execution thread;</li><li>values of global variables;</li><li>the list of loaded and unloaded modules.</li></ul>
<p>
The actual content of the minidump depends on the minidump type you pass as <a class="el" href="struct_c_r___i_n_s_t_a_l_l___i_n_f_o_a.html#9e09d512b1b4568028f0718dc3856ce2">CR_INSTALL_INFO::uMiniDumpType</a> member.<p>
In order to recover the stack trace from the crash minidump, you need the debugging symbols (program database, PDB) generated by the linker for important modules of your application.<h2><a class="anchor" name="opening_minidump_in_vs">
Opening Minidump in Visual Studio</a></h2>
In order to illustrate how to open a minidump file, I will use the minidump file created for <b>WTLDemo.exe</b> demo application that is distributed with CrashRpt archive. I use the following steps to create such minidump:<p>
<ul>
<li>I download CrashRpt archive to some directory. Then I unzip my archive to <em>D:\Projects\CrashRpt\dmptest</em> folder.</li><li>In the top-level directory, I open <em>CrashRpt_vs2010.sln</em> file (because I have Visual Studio 2010 installed) and compile CrashRpt in Release configuration as described in <a class="el" href="compiling_crashrpt.html">Compiling CrashRpt</a>.</li><li>Then I go to the <em>bin</em> directory. I see that the Visual Studio created several EXE, DLL and PDB files for me. Then I close Visual Studio window.</li><li>Next I save the binary files, debugging information and source code to some directory as described in <a class="el" href="preparing_to_software_release.html">Preparing to Software Release</a>. I just copy the <em>bin</em> directory to <em>D:\Projects\CrashRptSaved</em> directory and (because I use SVN to store my code) make SVN checkout to <em>D:\Projects\CrashRptSaved\src</em> directory.</li><li>Next I go to the <em>bin</em> directory again and run the <b>WTLDemo.exe</b>. When dialog appears, I click the "Crash" button. When <em>Error Report</em> dialog appears, I click the "What does this error report contains?" link. Then in the <em>Error Report Details</em> dialog, I click the "Export..." button to export the error report files as a ZIP archive. I export my error report to <em>D:\Projects\ErrorReports</em> directory.</li><li>And then I unzip the error report archive, which contains <b>crashdump.dmp</b> file and several other files.</li></ul>
<p>
Finally, I have the following directry structure:<ul>
<li>D:\<ul>
<li>Projects<ul>
<li>CrashRpt<ul>
<li>dmptest</li></ul>
</li><li>CrashRptSaved<ul>
<li>bin</li><li>src</li></ul>
</li><li>ErrorReports</li></ul>
</li></ul>
</li></ul>
<p>
Now, when you have <b>crashdump.dmp</b> file, you can open it in Visual Studio. In order to open crash minidump file, double-click its file name. Alternatively, if you have several versions of Visual Studio installed (for example a commercial one and an Express edition) right-click the filename and in the context menu select <em>Open With</em> and then choose what Visual Studio version to use.<p>
A new Visual Studio window appears. In the Visual Studio window, you should be able to see the solution called <em>crashdump</em> and having single project node called <b>crashdump.dmp</b>.<p>
<div align="center">
<img src="crashdump_sln.png" alt="crashdump_sln.png">
<p><strong>Solution Explorer: crashdump</strong></p></div>
 In the Visual Studio window, open menu <em>Debug-&gt;Start debugging</em> (or press F5) to load the minidump data. When minidump is loaded, you will see the dialog containing information about the exception, such as exception address, module name, exception code and its textual description (see the figure below). Press the 'Break' button to continue.<p>
<div align="center">
<img src="vs_unhandled_exception.png" alt="vs_unhandled_exception.png">
<p><strong>Unhandled Exception Message</strong></p></div>
 In the <em>Output</em> window, you should be able to see the log of minidump loading progress. If you do not see the <em>Output window</em>, open menu <em>View</em> and click the <em>Output</em> menu item.<p>
<div align="center">
<img src="output_window.png" alt="output_window.png">
<p><strong>Output Window</strong></p></div>
 Now look at the <em>Modules</em> window. If you do not see such window, open menu <em>Debug-&gt;Windows</em> and select the <em>Modules</em> menu item. Click the <em>Symbol Status</em> column header twice to sort modules by symbol load status in descending order. Now you should be able to see that symbols are loaded for <b>WTLDemo.exe</b> and <b>CrashRpt.dll</b> modules.<p>
<div align="center">
<img src="modules.png" alt="modules.png">
<p><strong>Modules: Symbols load status for each module</strong></p></div>
 As the debug symbols seem to be loaded successfully for main modules of the application, in the code window you should be able to see the place in your source code where the exception occurred. I see that the crash occurred in file <em>CrashRpt.cpp</em> at line 706 inside of <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> function because of assigning a null pointer variable with the value 0.<p>
You can see values of local variables by moving the mouse cursor over the variable name. The value (if known) is displayed in a tooltip window. Not all variable's values can be recovered, this depends on the minidump type you use and on other factors, such as code optimizations.<p>
<div align="center">
<img src="code_line.png" alt="code_line.png">
<p><strong>Line of the code where exception occurred</strong></p></div>
 If the reason of the crash is clear, you even may edit the source code right in place to fix the problem.<p>
In order to better understand the reason of the crash, I would like to know what C++ class or function called the <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> function and for what purpose. I can do this with the help of the <em>Call stack</em> window (see the figure below). If the Call stack window is hidden, open menu <em>Debug-&gt;Windows</em> and select the 'Call Stack' menu item.<p>
<div align="center">
<img src="call_stack.png" alt="call_stack.png">
<p><strong>Call Stack</strong></p></div>
 Each line (also called a <em>stack frame</em>) of the stack trace contains the name of module the code belongs to, the name of symbol (function or class), offset from beginning of symbol code, source file and line number. Moving down the stack, I see that <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> was called by the <b>CMainDlg::DoCrash()</b> class method, which, in turn was called by the <b>CMainDlg::OnOK()</b> method as the result of button click.<p>
Typically, the program has several execution threads. You can switch between threads using the <em>Threads</em> tab and browse the stack for each thread. I see that there are two threads in the application: <b>__tmainCRTStartup</b> and <b>CrashThread</b>. The exception occured in the main thread, the second thread didn't crash.<p>
<div align="center">
<img src="threads.png" alt="threads.png">
<p><strong>Threads Window</strong></p></div>
 Finally, when you have finished with analyzing minidump data, close the Visual Studio window. If Visual Studio offers you to save the solution, click the 'No' button.<h2><a class="anchor" name="troubleshooting_pdb">
Troubleshooting</a></h2>
The case described above is the easiest one, because Visual Studio located all binaries, PDB files and source files automatically. But in general, there may be some problems with reading minidumps, when Visual Studio can't locate such files.<p>
In order to locate matching binaries, PDB files and source code files, Visual Studio uses the absolute paths embedded into the executable file at the time of compilation and linking. So, when you do not delete/move/modify the files you used to build the solution, Visual Studio can locate them automatically. But, if you delete/move or modify those files, Visual Studio won't be able to locate them. In order to illustrate such case, I will remove the entire <em>D:\Projects\CrashRpt\dmptest</em> folder that contained CrashRpt source code I used for compilation, resulting binaries and PDB files. Then I open the minidump again and see the message 'No symbols are loaded for any stack frame. The source code can't be displayed' (see the figure below).<p>
<div align="center">
<img src="no_symbols_loaded.png" alt="no_symbols_loaded.png">
<p><strong>No Symbols Loaded</strong></p></div>
 Also look at the <em>Modules</em> window - symbol status for <b>WTLDemo.exe</b> and <b>CrashRpt.dll</b> modules shows that there were no matching binaries found. In order to fix this, you should specify symbol search path manually. Open menu <em>Tools-&gt;Options-&gt;Debugging-&gt;Symbols</em> and enter the path to the directory where your PDB files are located (see the figure below for example).<p>
<div align="center">
<img src="symbols_load_paths.png" alt="symbols_load_paths.png">
<p><strong>Where to load symbols from</strong></p></div>
 Now reload the minidump (stop the debugging and start it again). You see that the stack trace is now recovered correctly. But there is still one problem - the correct source code files are not displayed. In the <em>Call Stack</em> window, double-click the topmost stack frame. A dialog titled 'Find Source: crashrpt.cpp' will appear. In this dialog, browse to the <em>D:\Projects\CrashRptSaved\src\reporting\crashrpt</em> folder. Now the correct source file should be displayed in Visual Studio source code window.<p>
At this point, you should be able to read the minidump correctly. If there are still some problems, follow the instructions below:<p>
<ul>
<li>Maybe correct matching binaries and/or PDB files weren't saved after compilation. Ensure you save excatly the same binaries and PDB files that were generated during the compilation/linking process.</li></ul>
<p>
<ul>
<li>If symbols for some modules of your program are loaded, and you are still unable to read the stack trace, than there were no debugging symbols generated for the module where crash had occurred. Check that you set Program Database (/Zi) compiler flag and Generate Debug Info (/DEBUG) linker flag for all modules of your application. For additional info, see <a class="el" href="configuring_project.html#prgdb">Enabling Program Database (/Zi, /DEBUG) in Release Configuration</a>.</li></ul>
<p>
<ul>
<li>If the stack trace is not as accurate as you expect, the reason may be the code optimizations. However, this is not the reason to turn the optimizations off. Instead, you can manage some error log file which is not affected by optimizations.</li></ul>
<h2><a class="anchor" name="opening_minidump_in_windbg">
Opening Minidump in WinDbg</a></h2>
You can use <b>WinDbg</b> program from <b>Microsoft Debugging Tools for Windows</b> for opening crash minidumps. It is freely distributed.<p>
Let's show how to use WinDbg using an example. Run the sample <em>WTLDemo</em> application that presents in CrashRpt package, and then click the button to generate an exception. Then extract the <b>crashdump.dmp</b> file from the crash report, launch WinDbg, and open the crash dump by pressing CTRL+D key combination.<p>
Next, you need to set the symbol path for WinDbg with the <code></code>.sympath command. Switch to the command window (ALT+1) and enter <code></code>.sympath followed by a space followed by the semi-colon delimited list of directories to search.<p>
<div class="fragment"><pre class="fragment">.sympath D:\CrashRptSaved\WTLDemo_v1.1.0
</pre></div><p>
Similarly you need to set the executable and source search paths with the .exepath and <code></code>.srcpath commands.<p>
<div class="fragment"><pre class="fragment">.exepath D:\CrashRptSaved\WTLDemo_v1.1.0
.srcpath D:\Projects\CrashRpt\demos\WTLDemo
</pre></div><p>
The final step is to change the debugger context to the context record associated with the exception by entering the <code></code>.ecxr command.<p>
<div class="fragment"><pre class="fragment">.ecxr
</pre></div><p>
If everything is configured correctly, you should now be able to walk the call stack, see local variables, and loaded modules. You can even have WinDbg highlight the offending line of code by double clicking the WTLDemo frame in the Call Stack window (ALT+6). Note: The exact line number may be a little off due to linker optimizations.<p>
<b>If I've saved all the source code, should building from the source recreate the correct PDBs to be able to use them for reading the minidump?</b><p>
No, the recreated PDB files will not be the same as the original ones. The recreated PDB files won't have matching time stamp (or GUID in a never versions of dbghelp). The building environment may also be different, so generated binaries may be different.<p>
The recommended way is to save the original PDB files (that were produced when building the project), binary files (EXE and DLL) along with the source code.<p>
<em>Further reading:</em> <a class="el" href="automating_crash_report_processing.html">Automating Crash Report Processing</a>. </div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Tue Jan 15 15:06:21 2013 for CrashRpt by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9</small></address>
</body>
</html>
